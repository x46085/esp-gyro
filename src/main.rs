use anyhow::{bail, Result};
use embedded_hal::blocking::delay::DelayMs;
use esp_idf_svc::eventloop::EspSystemEventLoop;
use esp_idf_svc::hal::{
    delay::FreeRtos,
    i2c::{I2cConfig, I2cDriver},
    peripherals::Peripherals,
    prelude::*,
};
use log::info;
use rgb_led::{RGB8, WS2812RMT};
use wifi::wifi;

use icm42670::{Address, Icm42670, PowerMode as imuPowerMode};
use shared_bus::BusManagerSimple;
use shtcx::{self, PowerMode as shtPowerMode};

use std::net::UdpSocket;

/// This configuration is picked up at compile time by `build.rs` from the
/// file `cfg.toml`.
#[toml_cfg::toml_config]
pub struct Config {
    #[default("Wokwi-GUEST")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
    #[default("34343")]
    udp_port: &'static str,
}

fn main() -> Result<()> {
    esp_idf_svc::sys::link_patches();
    esp_idf_svc::log::EspLogger::initialize_default();

    let peripherals = Peripherals::take().unwrap();
    let sysloop = EspSystemEventLoop::take()?;

    // Start the LED off yellow
    let mut led = WS2812RMT::new(peripherals.pins.gpio2, peripherals.rmt.channel0)?;
    led.set_pixel(RGB8::new(50, 50, 0))?;

    // The constant `CONFIG` is auto-generated by `toml_config`.
    let app_config = CONFIG;
    info!("Connecting to Wifi..");

    // Connect to the Wi-Fi network
    let _wifi = match wifi(
        app_config.wifi_ssid,
        app_config.wifi_psk,
        peripherals.modem,
        sysloop,
    ) {
        Ok(inner) => inner,
        Err(err) => {
            // Red!
            led.set_pixel(RGB8::new(50, 0, 0))?;
            bail!("Could not connect to Wi-Fi network: {:?}", err)
        }
    };

    // 1. Instanciate the SDA and SCL pins, correct pins are in the training material.
    let sda = peripherals.pins.gpio10;
    let scl = peripherals.pins.gpio8;
    // 2. Instanciate the i2c peripheral
    let config = I2cConfig::new().baudrate(400.kHz().into());
    let i2c = I2cDriver::new(peripherals.i2c0, sda, scl, &config)?;

    // 3. Instantiate the bus manager, pass the i2c bus.
    let bus = BusManagerSimple::new(i2c);

    // 4. Create two proxies. Now, each sensor can have their own instance of a proxy i2c, which resolves the ownership problem.
    let proxy_1 = bus.acquire_i2c();
    let proxy_2 = bus.acquire_i2c();

    // 5. Change your previous code, so that one of the proxies is passed to the SHTC3, instead of the original i2c bus.
    let mut sht = shtcx::shtc3(proxy_1);

    // 6. Read and print the device ID.
    let device_id = sht.device_identifier().unwrap();
    println!("Device ID SHTC3: {:#02x}", device_id);

    // 7. Create an instance of ICM42670p sensor. Pass the second proxy and the sensor's address.
    let mut imu = Icm42670::new(proxy_2, Address::Primary).unwrap();

    // 8. Read the device's ID register and print the value.
    let device_id = imu.device_id().unwrap();
    println!("Device ID ICM42670p: {:#02x}", device_id);

    // 9. Start the ICM42670p in low noise mode.
    imu.set_power_mode(imuPowerMode::GyroLowNoise).unwrap();

    let addr = "127.0.0.1:".to_owned() + app_config.udp_port;
    let socket = UdpSocket::bind(addr.to_owned())?;

    println!("Sampling, example:");

    let gyro_data = imu.gyro_norm().unwrap();
    sht.start_measurement(shtPowerMode::NormalMode).unwrap();
    FreeRtos.delay_ms(100u32);
    let measurement = sht.get_measurement_result().unwrap();

    println!(
        "TEMP: {:.2} Â°C | HUM: {:.2} % | GYRO: X= {:.2}  Y= {:.2}  Z= {:.2}",
        measurement.temperature.as_degrees_celsius(),
        measurement.humidity.as_percent(),
        gyro_data.x,
        gyro_data.y,
        gyro_data.z,
    );

    let mut message_count = 0u32;

    loop {
        led.set_pixel(RGB8::new(0, 50, 0))?;
        
        let gyro_data = imu.gyro_norm().unwrap();

        let buf = [
            message_count.to_ne_bytes(),
            gyro_data.x.to_ne_bytes(), 
            gyro_data.x.to_ne_bytes(), 
            gyro_data.x.to_ne_bytes()]
            .concat();

        socket.send_to(&buf, addr.to_owned())?;

        message_count += 1;

        led.set_pixel(RGB8::new(0, 0, 50))?;

    }
}
